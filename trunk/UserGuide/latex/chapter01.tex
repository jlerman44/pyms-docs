% chapter01.tex

 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %                                                                           %
 %    PyMS documentation                                                     %
 %    Copyright (C) 2005-8 Vladimir Likic                                    %
 %                                                                           %
 %    The files in this directory provided under the Creative Commons        %
 %    Attribution-NonCommercial-NoDerivs 2.1 Australia license               %
 %    http://creativecommons.org/licenses/by-nc-nd/2.1/au/                   %
 %    See the file license.txt                                               %
 %                                                                           %
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{PyMS User Guide}

%%% section %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{About PyMS}

PyMS is a Python toolkit for processing of chromatography--mass spectrometry
data. The idea behind PyMS is to provdie a set of components for the development
of new methods for processing of chromatography--mass spectrometry data, and to
decouple processing methods form visualization and the concept of interactive
processing.

Current PyMS development is strongly influenced by the needs in processing of gas
chromatography-mass spectrometry (GC-MS) data.

PyMS is highly modular and consists of several sub-packages written in Python
programming language \cite{python}. PyMS is released as open source, under
the GNU Public License version 2.


%%% section %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{PyMS installation}

The instructions below refer to installation under Linux, and assume
a reasonably savvy Linux user.  Python is however fully cross-platform
compatible, and PyMS should work equally well under other operating
systems as long as the dependencies can be satisfied.

\subsection{Preparing the environment for a local installation}

There are two methods of installing PyMS dependencies. The first is
{\it system-wide}, when root access is available. The second is {\it locally},
when write access to the system directories is unavailable, or when PyMS is
only used by one user. In this case, the dependencies are installed into a
user's home directory.

Before performing a local installation, the following extra two steps are
required.

\begin{description}
  \item [Directory structure:] \
        Create a directory for the dependencies to install into. For this
        guide, we choose \~{}/pyms-deps.
  \item [Environment variables:] \
        The \$PATH variable needs to be configured for the target installation
        directory. In the case of the bash shell, add
        {\tt PATH=\$HOME/pyms-deps/bin:\$PATH} to your .bash\_profile file,
        then reopen the terminal.
\end{description}

\subsection{Python}

Python is a general purpose object oriented programming language, which
PyMS is written in.  Python is open source and freely available
from \url{http://www.python.org/download}.

The instructions below refer to the installation of Python version
2.5.

\begin{description}
\item [Filename:] {\tt Python-2.5.tgz}
\item [Installation:] $ $
  \begin{enumerate}
  \item {\tt tar -zxvf Python-2.5.tgz}
  \item {\tt cd Python-2.5}
  \item {\tt ./configure} {\it if installing system-wide, or}\newline
        {\tt ./configure --prefix=\$HOME/pyms-deps} {\it if installing locally}
  \item {\tt make}
  \item {\tt make install}
  \end{enumerate}
Please refer to the file {\tt Python-2.5/README} for more details.
\end{description}

\subsection{netCDF}

netCDF (network Common Data Form) is an interface for array-oriented
data access and a library that provides an implementation of the
interface. The netCDF library also defines a machine-independent
format for representing scientific data. Together, the interface,
library, and format support the creation, access, and sharing of
scientific data.

netCDF is available from \url{http://www.unidata.ucar.edu/downloads/netcdf/}.

The description below refers to the installation of netCDF version
3.6.1.

\begin{description}
\item [Filename:] {\tt netcdf-3.6.1.tar.gz}
\item [Installation:] $ $
  \begin{enumerate}
  \item {\tt tar -zxvf netcdf-3.6.1.tar.gz}
  \item {\tt cd netcdf-3.6.1/src}
  \item {\tt ./configure} {\it if installing system-wide, or}\newline
        {\tt ./configure --prefix=\$HOME/pyms-deps} {\it if installing locally}
  \item {\tt make}
  \item {\tt make install}
  \end{enumerate}
Please refer to the file {\tt netcdf-3.6.1/src/INSTALL} for more details.
\end{description}

\subsection{numarray}

numarray is a set of extensions to the Python programming language which
allows large sets of numerical values to be efficiently manipulated.

numarray is available from \url{http://www.stsci.edu/resources/software_hardware/numarray}.

The description below refers to the installation of numarray version
1.5.2.

\begin{description}
\item [Filename:] {\tt numarray-1.5.2.tar.gz}
\item [Installation:] $ $
  \begin{enumerate}
  \item {\tt tar -zxvf numarray-1.5.2.tar.gz}
  \item {\tt cd numarray-1.5.2}
  \item {\tt python setup.py config install --gencode}
  \end{enumerate}
Please refer to the file {\tt numarray-1.5.2/Doc/INSTALL.txt} for more
details.
\end{description}

\subsection{pycdf}

pycdf is a set of extensions to the Python programming language
providing an interface to to the netCDF library. The description
below refers to the installation of pycdf version 0.6-2-rc1.

pycdf is available from \url{http://pysclint.sourceforge.net/pycdf/}.

The description below refers to the installation of pycdf version
0.6-2-rc1.

\begin{description}
\item [Filename:] {\tt pycdf-0.6-2-rc1.tar.gz}
\item [Installation:] $ $
  \begin{enumerate}
  \item {\tt tar -zxvf pycdf-0.6-2-rc1.tar.gz}
  \item {\tt cd pycdf-0.6-2-rc1}
  \item {\tt vi setup.py}
    \begin{enumerate}
    \item At line 31 ({\tt USE = NUMERIC}), add a \# at the start of the line
    \item At line 32 ({\tt \#USE = NUMARRAY}), remove the \# at the start
    of the line
    \item Save the file and exit
    \end{enumerate}
  \item {\tt python setup.py install}
  \end{enumerate}
Please refer to the file {\tt pycdf-0.6-2-rc1/INSTALL} for more details.
\end{description}

\subsection{matplotlib}

matplotlib is a python 2D plotting library.  It is used by pyms for 
visualizations of data.

matplotlib is available from \url{http://matplotlib.sourceforge.net/}.

The description below refers to the installation of matplotlib version
0.87.7.

\begin{description}
\item [Filename:] {\tt matplotlib-0.87.7.tar.gz}
\item [Installation:] $ $
  \begin{enumerate}
  \item Ensure that you have the preequisites for matplotlib's GUI
        extensions, as the plots will not display otherwise. Any one of
        the following can be used:
        \begin{enumerate}
        \item pygtk
        \item wxpython
        \item tk
        \end{enumerate}
  \item {\tt tar -zxvf matplotlib-0.87.7.tar.gz}
  \item {\tt cd matplotlib-0.87.7}
  \item {\tt python setup.py build}
  \item {\tt python setup.py install}
  \end{enumerate}
Please refer to the file {\tt matplotlib-0.87.7/INSTALL} for more
details.
\end{description}

\section{Installing optional dependencies}

Optional dependencies are packages which are not required for the
core functionality of PyMS, but may be required for some extra
functionality, or are highly recommended (such as IPython, interactive
Python shell). 

\subsection{IPython}

IPython is enhanced Python shell suitable for interactive work.

IPython is available from \url{http://ipython.scipy.org/moin/}.

The description below refers to the installation of IPython version
0.7.3.

\begin{description}
\item [Filename:] {\tt ipython-0.7.3.tar.gz}
\item [Installation:] $ $
  \begin{enumerate}
  \item {\tt tar -zxvf ipython-0.7.3.tar.gz}
  \item {\tt cd ipython-0.7.3}
  \item {\tt python setup.py install}
  \end{enumerate}
Please refer to the file {\tt ipython-0.7.3/doc/manual.pdf} for more
details.
\end{description}

\subsection{Numeric}

Numeric is Python module for high-performance numeric computing.
This module is required by Pycluster, and needs to be installed
only if Pycluster is used (see below).

Numeric is available from
\url{http://optusnet.dl.sourceforge.net/sourceforge/numpy/Numeric-24.2.tar.gz}.

The description below refers to the installation of Numeric version
24.2.

\begin{description}
\item [Filename:] {\tt Numeric-24.2.tar.gz}
\item [Installation:] $ $
  \begin{enumerate}
  \item {\tt tar -zxvf Numeric-24.2.tar.gz}
  \item {\tt cd Numeric-24.2}
  \item {\tt python setup.py build}
  \item {\tt python setup.py install}
  \end{enumerate}
Please refer to the file {\tt Numeric-24.2/README} for more
details.
\end{description}

\subsection{Pycluster}

Pycluster is a Python extension module to the clustering routines
in the C Clustering Library by Michiel de Hoon.  Most people will
not use this PyMS, and the installation is highly optional. 

Pycluster is available from
\url{http://bonsai.ims.u-tokyo.ac.jp/~mdehoon/software/cluster/software.htm}.

The description below refers to the installation of Pycluster version
1.33.

\begin{description}
\item [Filename:] {\tt Pycluster-1.33.tar.gz}
\item [Installation:] $ $
  \begin{enumerate}
  \item {\tt tar -zxvf Pycluster-1.33.tar.gz}
  \item {\tt cd Pycluster-1.33}
  \item {\tt python setup.py install}
  \end{enumerate}
\end{description}

\section{PyMS}

\subsection{Downloading PyMS source code}

PyMS source code resides on Google Code servers, and can be accessed
from the following URL: http://code.google.com/p/pyms/. Under the
section "Source" one can find the instructions for downloading the
source code. The same page provides the link under "This project's
Subversion repository can be viewed in your web browser" which allows
one to browse the source code on the server without actually downloading
it.

Google Code servers maintain the source code by the program called
'subversion' (an open-source version control system).  To download the
source code one needs to use the subversion client program called 'svn'.
The 'svn' client exists for all mainstream operating systems\footnote{For
example, on Linux CentOS 4 we have installed the RPM package
'subversion-1.3.2-1.rhel4.i386.rpm' to provide us with the subversion
client 'svn'.}, for more information see http://subversion.tigris.org/.
The book about subversion is freely available on-line at
http://svnbook.red-bean.com/. Subversion has extensive functionality
however only the very basic functionality is needed to download PyMS
source code.

If the computer is connected to the internet and the subversion client
is installed, the following command will download the latest PyMS 
source code in the current directory:

\begin{verbatim}
$ svn checkout http://pyms.googlecode.com/svn/trunk/ pyms
A    pyms/Peak
A    pyms/Peak/__init__.py
A    pyms/Peak/List
A    pyms/Peak/List/__init__.py
.....
A    pyms/Noise/Window.py
Checked out revision 30.
$ ls -CF
pyms/
$
\end{verbatim}

\subsection{PyMS installation}

The process described above shows the installation of netCDF, numarray,
and pycdf within the Python standard distribution. This is typically
a directory named "site-packages" withini the Python installation
directory (for example, /usr/local/lib/python2.4). For example, if
"pycdf" and "numarray" are installed listing files in this directory
would show:

\begin{verbatim}
$ ls -CF /usr/local/lib/python2.4/site-packages
pycdf/ numarray/
$ 
\end{verbatim}

To install PyMS one needs to copy PyMS source directory to
the site-packages directory:

\begin{verbatim}
$ cp -r pyms /usr/local/lib/python2.4/site-packages
\end{verbatim}

The easiest way to test if PyMS has been installed properly is 
to attempt to import the package within the Python environment:

\begin{verbatim}
$ python
Python 2.4.1 (#1, Jun 27 2005, 12:53:02) 
[GCC 3.4.3 20041212 (Red Hat 3.4.3-9.EL4)] on linux2
Type "help", "copyright", "credits" or "license" for more information.
>>> import pyms
>>>
\end{verbatim}

It there are no feedback messaged to the import command, Python
was able to load PyMS. 

\subsection{Installing PyMS elsewhere}

Installing PyMS in the python standard directory may require
super-user password. The alternative installation is to install
PyMS somewhere locally. For example, the directory pyms/ with
PyMS source code could be placed in the directory /home/projects/.
To make Python aware of PyMS the following commands are required
before any part of PyMS is called:

\begin{verbatim}
import sys
sys.path.append("/home/projects")
\end{verbatim}

Alternatively the environment variable PYTHONPATH could be set
to "/home/projects/". For example, under the bash shell: 

\begin{verbatim}
$ PYTHONPATH=/home/projects/; export PYTHONPATH
\end{verbatim}

More information about sys.path.append() and PYTHONPATH is possible
to find in Python documentation.

\section{IPython}

IPython is a substitute for the stock Python interactive shell. It
provides several features which enhances the day-to-day workflow of
using PyMS, but is not required for its operation.

Its improvements include:
\begin{enumerate}
    \item {\bf Tab completion:} Press the {\tt TAB key} to autocomplete
          variable and function names, and directory entries.
    \item {\bf Object inspection:} Type {\tt \$objectname} to obtain
          information and documentation about it.
    \item {\bf Shell passthrough:} Type {\tt !commandname} to execute a
          shell command. The output of the command can be assigned to a
          variable if necessary.
    \item {\bf Color highlighting:} Input and output are highlighted in
          different colors for easier distinguishing.
    \item {\bf Command history:} Press {\tt UP} or {\tt DOWN} to scroll through the
          command history, and {\tt CTRL-R} to search through the history. The
          history is persistent across sessions.
    \item {\bf Logging:} Input can be logged to a file, allowing for
          future inspection or replay. Type {\tt \%logstart logname}
          in IPython to activate logging.
\end{enumerate}

IPython can be obtained from \url{http://ipython.scipy.org/dist/}. The
description below refers to the installation of IPython version 0.7.2.

\begin{description}
\item [Filename:] {\tt ipython-0.7.2.tar.gz} (or newer)
\item [Installation:] $ $
  \begin{enumerate}
  \item {\tt tar -zxvf ipython-0.7.2.tar.gz}
  \item {\tt cd ipython-0.7.2}
  \item {\tt python setup.py build}
  \item {\tt python setup.py install}
  \end{enumerate}
\end{description}

%%% section %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Reading GC-MS data}

\subsection{ANDI-MS data format}

The field of chromatography--mass spectrometry is ruled by proprietary, closed
data formats.  Anything that comes even closse to an open standard is the
incomplete and now obsolete ANDI-MS data format.

ANDI-MS data format stands for Analytical Data Interchange for Mass
Spectrometry, and was developed for the description of mass spectrometric
data developed in 1994 by Analytical Instrument Association. ANDI-MS 
is essentially a recommendation, and it is up to individual vendors of
mass spectrometry processing software to implement "export to ANDI-MS"
feature in their software. Furthermore, it is vendor's good will to
implement ANDI-MS specifications properly. Because of these limitations
it is difficult to be certain that one can properly read ANDI-MS files
from a particular vendor without testing this first.

\subsection{Reading the data in PyMS}

The PyMS package pyms.IO provides capabilities to read the raw GC-MS
data stored in the ANDI-MS format. The function IO.ANDI.ChemStation()
provides the interface to ANDI-MS data files saved from Agilent
ChemStation software. The name is a reminder that this function has
been reasonably tested only on the data exported from Agilent ChemStation.

In an interactive session from Python, the ANDI-MS file can be loaded
in the memory as follows:

\begin{verbatim}
>>> from pyms import IO
>>> data = IO.ANDI.Class.ChemStation('0510_217.CDF')
 -> Processing netCDF file '0510_217.CDF'
    [ 2784 scans, masses from 50 to 550 ]
>>>
\end{verbatim}

Where '0510\_217.CDF' is the name of the GC-MS data saved in the ANDI-MS
format from the Agilent ChemStation software.  The above command creates
the object 'data' which is an {\em instance} of the class IO.ANDI.ChemStation.
The instance 'data' has several attributes and methods associated with it:

\begin{itemize}

\item {\tt get\_filename()} -- Returns the name of the file from which
the data was loaded. Usage example:

\begin{verbatim}
>>> data.get_filename()
'0510_217.CDF'
\end{verbatim}

\item {\tt get\_ic\_at\_index(i)} -- Returns an IonChromatogram object
at index i.  For example, to get the first ion chromatogram from the data
matrix:

\begin{verbatim}
>>> ic = data.get_ic_at_index(1)
\end{verbatim}

\noindent
An IonChromatogram object is the one dimensional time vector containing
mass intensities.  One often deals with two types of IonChromatogram
objects: ion chromatograms at particular m/z value (for example, ion
chromatograms at m/z = 65), or total ion chromatograms (TICs), which
contain the sum of intensities for all masses at any given time point. 
The nature of an IonChromatogram object can be revealed by the content
of the attribute '\_mass', which is set to None if the ion chromatogram
is TIC; otherwise it contains the m/z value of the ion chromatogram.
Continuing the previous example:

\begin{verbatim}
>>> ic._mass
51
\end{verbatim}

\noindent
This shows that the first ion chromatogram in the data file is for
m/z = 51.

\item {\tt get\_ic\_at\_mass(mz)} -- Returns an IonChromatogram
object corresponding to given m/z. For example, to get the ion
chromatogram that corresponds to m/z = 73:

\begin{verbatim}
>>> ic = data.get_ic_at_mass(73)
>>> ic._mass
73
\end{verbatim}

\item {\tt get\_intensity\_matrix()} -- Returns the entire data
matrix, i.e. time vs m/z as numarray object. Usage example:

\begin{verbatim}
>>> im = data.get_intensity_matrix()
>>> len(im)
2784
>>> len(im[0])
501
\end{verbatim}

This data matrix contains 2784 time points (MS scans) and each time
point corresponds to a mass spectrum of 501 m/z points.

\end{itemize}

%%% section %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Minmax peak detector}

\subsection{Introduction}

Minmax peak detector is the simplest kind of a peak finding algoritam for
TIC. It operates by finding peak maxima, and then attempting to determine
peak boundaries. Cursory evidence suggests that gives results similar to
the ChemStation peak detection, but this was not examined rigorously.
The purpose of this algorithm is to provide an example of how 1D peak
pickin can be implemented in PyMS. {\em At present the Minmax algorithm
was not properly tested, do not use it for critical publication quality
results}.

\subsection{A brief description of the algorithm}

Many peak detection algorithms are used in practice to process GC/LC-MS data,
but only a few are fully documented, most notable those of open source
projects MZmine \cite{katajamaa06} and XCMS \cite{smith06}.  MZmine detects
peaks by finding local maxima of a certain width \cite{katajamaa06}. In XCMS
peaks are detected by using an empirical signal-to-noise cutoff after matched
filtration with a second-derivative Gaussian \cite{smith06}. PyMS peak
detection procedure was developed in-house, and relies on finding local
maxima and local minima in the signal, followed by a subsequent refinement
of peak left and right boundaries. Peak detection depends on two input
parameters: window width over which a peak is expected to be a global maximum,
and the scaling factor $S$ used to calculate the intensity threshold $S
\sigma$ which must be exceeded at the peak apex. The noise level $\sigma$
is estimated prior to peak detection by repeatedly calculating median
absolute deviation (MAD -- a robust estimate of the average deviation) over
randomly placed windows and taking the minimum. A detailed description of
procedures for peak detection follows. 

\begin{enumerate}
\item {\bf Extracting local maxima}. Initially, an ordered list of
local maxima in the signal with an intensity larger than a threshold
is compiled. Two input parameters are specified by the user: the
width of a window over which the peak is required to be a global
maximum ($W$); and (2) the scaling factor $S$ used to calculate intensity
threshold $S \sigma$, where $S$ is the noise level estimated previously
(defaults: $W = 2$ data points, $S = 10$).  User specified window is
centered on each point of the signal, and the point is deemed
to be a local maximum if the following is satisfied:

   \begin{enumerate}
   \item It is equal or greater than all of the points within
         the window W.
   \item It is greater than at least one point in the half-window
         interval to the left, and at least one point in the
         half-window interval to the right.\footnote{This is
         to reject points within intervals of uniform intensity}
   \item Any point closer to the edge of the signal than half-window
         is rejected.
   \end{enumerate}

Intensity at each local maxima is tested, and those that have the
intensity below the threshold N*S are rejected. Accepted local
maxima are compiled into a list.

\item {\bf Determination of peak left/right boundaries}. For each
local maxima (base maximum) the stretch of the signal between itself
and the next local maximum on either side is extracted.  These
two signal slices are searched for the first local minimum in
the direction away from the base maximum point itself. The local
maxima are defined in a very similar manner as the local maxima
in the previous step.  A point is deemed to be a local maximum if:

   \begin{enumerate}
   \item It is equal or smaller than all the points within the
        window W.
   \item It is smaller than at least one point in the half-window
        interval to the left, and at least one point in the
        half-window interval on the right.
   \item Any point closer to the edge of the slice than half-window
        is rejected. This has the effect that the boundary point
        cannot approach next peak's apex closer than half-window.
   \item If no minimum point is found, set the boundary point to
        the point furtherest away from the base maximum, but
        outside to the half-window range of the adjacent peak.
   \end{enumerate}

\item {\bf Elimination of peak overlaps}. In spectra dense with
peaks peak boundaries as found in the step (2) may overlap due to
the effect of user supplied window. The list of pre-peaks is
searched for overlapping peaks. In overlapping peaks the right
boundary of the lower retention time peak overlaps with the
left boundary of the higher retention time peak. The overlapping
boundaries are resolved by finding the point of minimum intensity
between the two peaks (the split point). The peak boundaries are
set to one point to the left from the split point for the right
boundary of the lower retention time peak, and to one point to
the right from the split point for the left boundary of the
higher retention time peak.

\item {\bf Correction for long tails}.  In this step peak boundaries
are adjusted to remove stretches of near-uniform intensities
(i.e. long tails). Each peak is divided at the apex into two
halves, and each half is processed individually in the
boundary-to-apex direction. A line is fitted through $M$ points
from the boundary in the least-squares sense. Prior to calculating
the angle between the line and the retention time axis, the
rise in intensity is normalized with the intensity at the peak
apex.  If this angle is below the user specified cutoff ($Q$)
the boundary point is dropped, and the process is repeated.
This adjustment is repeated until the best fit through $M$ points
from the boundary gives an angle greater than the cutoff. The
parameters $M$ and $Q$ are user specified (defaults: $M = 3$,
$Q = 1.0^\circ$).

\end{enumerate}

