% chapter01.tex

 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %                                                                           %
 %    PyMS documentation                                                     %
 %    Copyright (C) 2005-8 Vladimir Likic                                    %
 %                                                                           %
 %    The files in this directory provided under the Creative Commons        %
 %    Attribution-NonCommercial-NoDerivs 2.1 Australia license               %
 %    http://creativecommons.org/licenses/by-nc-nd/2.1/au/                   %
 %    See the file license.txt                                               %
 %                                                                           %
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Introduction}

\section{About PyMS}

PyMS is a Python toolkit for processing of chromatography--mass spectrometry
data. The main idea behind PyMS is to provde a framework and a set of
components for rapid development and testing of methods for processing of
chromatography--mass spectrometry data. An important objective of PyMS is
to decouple processing methods form visualization and the concept of
interactive processing. This is useful for high-throughput processing tasks
and when there is a need to run calculations in the batch mode.

PyMS is modular and consists of several sub-packages written in Python
programming language \cite{python}. PyMS is released as open source,
under the GNU Public License version 2.

There are four parts of the pyms project:

\begin{itemize}
  \item pyms -- The PyMS code
  \item pyms-docs -- The PyMS documentation
  \item pyms-test -- Examples of PyMS use
  \item pyms-data -- Data used in pyms-test 
\end{itemize}

Each part is a separate project on Google Code that can be downloaded
separately.

\section{PyMS installation}

There are many ways to install PyMS depending your computer configuration
and preferences. The recommended way install PyMS is to compile Python
from sources and install PyMS within the local Python installation. This
procedure is described in detail below.

PyMS has been developed on Linux, and a detailed installation instructions
for Linux are given below. Installation on any Unix-like system should be
similar. We have not tested PyMS under Microsoft Windows.

\subsection{Downloading PyMS source code}

PyMS source code resides on Google Code servers, and can be accessed
from the following URL: http://code.google.com/p/pyms/. Under the
section "Source" one can find the instructions for downloading the
source code. The same page provides the link under "This project's
Subversion repository can be viewed in your web browser" which allows
one to browse the source code on the server without actually downloading
it.

Google Code maintains the source code by the program called 'subversion'
(an open-source version control system).  To download the source code
one needs to use the subversion client program called 'svn'. The 'svn'
client exists for all mainstream operating systems\footnote{For example,
on Linux CentOS 4 we have installed the RPM package
'subversion-1.3.2-1.rhel4.i386.rpm' to provide us with the subversion
client 'svn'.}, for more information see http://subversion.tigris.org/.
The book about subversion is freely available on-line at
http://svnbook.red-bean.com/. Subversion has extensive functionality.
However only the very basic functionality is needed to download PyMS
source code.

If the computer is connected to the internet and the subversion client
is installed, the following command will download the latest PyMS source
code:

\begin{verbatim}
$ svn checkout http://pyms.googlecode.com/svn/trunk/ pyms
A    pyms/Peak
A    pyms/Peak/__init__.py
A    pyms/Peak/List
A    pyms/Peak/List/__init__.py
.....
Checked out revision 71.
\end{verbatim}

\subsection{PyMS installation}

PyMS installation consists of placing the PyMS code directory (pyms/) in
place visible to Python interpreter.  This can be in the standard place
for 3rd party software (the directory site-packages/). If PyMS code is
placed in a non-standard place the Python interpreter needs to be made
aware of it before before it is possible to import PyMS modules (see the
Python sys.path.append() command).

We recommend compiling your own Python installation for PyMS.

In addtion to the PyMS core source code, a number of external packages
is used to provide additional functionality. These are explained below.

\subsection{\label{subsec:numpy}Package 'NumPy'}

The package NumPy is provides numerical capabilities to Python. This
package is used throughout PyMS (and also required for some external
packages used in PyMS), to its installation is mandatory. 

The NumPy web site {\tt http://numpy.scipy.org/} provides the installation
instructions and the link to the source code.

\subsection{\label{subsec:pycdf}Package 'pycdf' (required for reading
ANDI-MS files)}

The pycdf (a python interface to Unidata netCDF library) source and
installation instructions can be downloaded from
{\tt http://pysclint.sourceforge.net/pycdf/}. Follow the installation
instructions to install pycdf. 

\subsection{\label{subsec:pycluster}Package 'Pycluster' (required for peak
alignment by dynamic programming)}

The peak alignment by dynamic programming is located in the subpackage
pyms.Peak.List.DPA. This subpackage used the Python package 'Pycluster'
as the clustering engine. Pycluster with its installation instructions
can be found here:
{\tt http://bonsai.ims.u-tokyo.ac.jp/~mdehoon/software/cluster/index.html}.

\subsection{\label{subsec:scipy-ndmage}Package 'scipy.ndimage' (required
for TopHat baseline correction)}

If the full SciPy package is installed the 'ndimage' will be available. However
the SciPy contains large amount of functionality, and its intallation is
somewhat involved. In some situations in may be preferable to install only
the subpackage 'ndimage'. The UrbanSim web site \cite{urbansim} provides
instructions how to install a local copy of 'ndimage'. These instructions
and the link to the file 'ndimage.zip' are here:\\
{\tt http://www.urbansim.org/opus/releases/opus-4-1-1/docs/installation/scipy.html}

\section{Current PyMS development environment}

PyMS is currently being developed with the following packages:

\begin{verbatim}
Python-2.5.2
numpy-1.1.1
pycdf-0.6-3b
Pycluster-1.41
\end{verbatim}

A quick installation guide for packages required by PyMS is given below.

\begin{enumerate}

\item Python installation:

\begin{verbatim}
$ tar xvfz Python-2.5.2.tgz
$ cd Python-2.5.2
$ ./configure
$ make
$ make install
\end{verbatim}

\noindent
This installs python in /usr/local/lib/python2.5.  Make sure that python called
from the command line is the one just compiled and installed.

\item NumPy installation:

\begin{verbatim}
$ tar xvfz numpy-1.1.1.tar.gz
$ cd numpy-1.1.1
$ python setup.py install
\end{verbatim}

\item pycdf installation

\begin{verbatim}
$ tar xvfz pycdf-0.6-3b
$ cd pycdf-0.6-3b
$ python setup.py install
\end{verbatim}

\item Pycluster installation

\begin{verbatim}
$ tar Pycluster-1.42.tar.gz
$ cd Pycluster-1.42
$ python setup.py install
\end{verbatim}

\item ndimage installation:

\begin{verbatim}
$ unzip ndimage.zip
$ cd ndimage
$ python setup.py install --prefix=/usr/local
\end{verbatim}

\noindent
Since ndimage was installed outside the scipy package, this requires some manual
correction:

\begin{verbatim}
$ cd /usr/local/lib/python2.5/site-packages
$ mkdir scipy
$ touch scipy/__init__.py
$ mv ndimage scipy
\end{verbatim}

\end{enumerate}

\section{Algorithms}

{\em Note: This section is temporarily here, it will be moved in the future
version of the User Guide.}

\subsection{Minmax peak detector}

Minmax peak detector is the simplest kind of a peak finding algoritam for
TIC. It operates by finding peak maxima, and then attempting to determine
peak boundaries. Cursory evidence suggests that gives results similar to
the ChemStation peak detection, but this was not examined rigorously.
The purpose of this algorithm is to provide an example of how 1D peak
pickin can be implemented in PyMS. {\em At present the Minmax algorithm
was not properly tested, do not use it for critical publication quality
results}.

\subsection{A brief description of the algorithm}

Many peak detection algorithms are used in practice to process GC/LC-MS data,
but only a few are fully documented, most notable those of open source
projects MZmine \cite{katajamaa06} and XCMS \cite{smith06}.  MZmine detects
peaks by finding local maxima of a certain width \cite{katajamaa06}. In XCMS
peaks are detected by using an empirical signal-to-noise cutoff after matched
filtration with a second-derivative Gaussian \cite{smith06}. PyMS peak
detection procedure was developed in-house, and relies on finding local
maxima and local minima in the signal, followed by a subsequent refinement
of peak left and right boundaries. Peak detection depends on two input
parameters: window width over which a peak is expected to be a global maximum,
and the scaling factor $S$ used to calculate the intensity threshold $S
\sigma$ which must be exceeded at the peak apex. The noise level $\sigma$
is estimated prior to peak detection by repeatedly calculating median
absolute deviation (MAD -- a robust estimate of the average deviation) over
randomly placed windows and taking the minimum. A detailed description of
procedures for peak detection follows. 

\begin{enumerate}
\item {\bf Extracting local maxima}. Initially, an ordered list of
local maxima in the signal with an intensity larger than a threshold
is compiled. Two input parameters are specified by the user: the
width of a window over which the peak is required to be a global
maximum ($W$); and (2) the scaling factor $S$ used to calculate intensity
threshold $S \sigma$, where $S$ is the noise level estimated previously
(defaults: $W = 2$ data points, $S = 10$).  User specified window is
centered on each point of the signal, and the point is deemed
to be a local maximum if the following is satisfied:

   \begin{enumerate}
   \item It is equal or greater than all of the points within
         the window W.
   \item It is greater than at least one point in the half-window
         interval to the left, and at least one point in the
         half-window interval to the right.\footnote{This is
         to reject points within intervals of uniform intensity}
   \item Any point closer to the edge of the signal than half-window
         is rejected.
   \end{enumerate}

Intensity at each local maxima is tested, and those that have the
intensity below the threshold N*S are rejected. Accepted local
maxima are compiled into a list.

\item {\bf Determination of peak left/right boundaries}. For each
local maxima (base maximum) the stretch of the signal between itself
and the next local maximum on either side is extracted.  These
two signal slices are searched for the first local minimum in
the direction away from the base maximum point itself. The local
maxima are defined in a very similar manner as the local maxima
in the previous step.  A point is deemed to be a local maximum if:

   \begin{enumerate}
   \item It is equal or smaller than all the points within the
        window W.
   \item It is smaller than at least one point in the half-window
        interval to the left, and at least one point in the
        half-window interval on the right.
   \item Any point closer to the edge of the slice than half-window
        is rejected. This has the effect that the boundary point
        cannot approach next peak's apex closer than half-window.
   \item If no minimum point is found, set the boundary point to
        the point furtherest away from the base maximum, but
        outside to the half-window range of the adjacent peak.
   \end{enumerate}

\item {\bf Elimination of peak overlaps}. In spectra dense with
peaks peak boundaries as found in the step (2) may overlap due to
the effect of user supplied window. The list of pre-peaks is
searched for overlapping peaks. In overlapping peaks the right
boundary of the lower retention time peak overlaps with the
left boundary of the higher retention time peak. The overlapping
boundaries are resolved by finding the point of minimum intensity
between the two peaks (the split point). The peak boundaries are
set to one point to the left from the split point for the right
boundary of the lower retention time peak, and to one point to
the right from the split point for the left boundary of the
higher retention time peak.

\item {\bf Correction for long tails}.  In this step peak boundaries
are adjusted to remove stretches of near-uniform intensities
(i.e. long tails). Each peak is divided at the apex into two
halves, and each half is processed individually in the
boundary-to-apex direction. A line is fitted through $M$ points
from the boundary in the least-squares sense. Prior to calculating
the angle between the line and the retention time axis, the
rise in intensity is normalized with the intensity at the peak
apex.  If this angle is below the user specified cutoff ($Q$)
the boundary point is dropped, and the process is repeated.
This adjustment is repeated until the best fit through $M$ points
from the boundary gives an angle greater than the cutoff. The
parameters $M$ and $Q$ are user specified (defaults: $M = 3$,
$Q = 1.0^\circ$).

\end{enumerate}

