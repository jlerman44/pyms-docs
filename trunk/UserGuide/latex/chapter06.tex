% chapter06.tex

 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %                                                                           %
 %    PyMS documentation                                                     %
 %    Copyright (C) 2005-8 Vladimir Likic                                    %
 %                                                                           %
 %    The files in this directory provided under the Creative Commons        %
 %    Attribution-NonCommercial-NoDerivs 2.1 Australia license               %
 %    http://creativecommons.org/licenses/by-nc-nd/2.1/au/                   %
 %    See the file license.txt                                               %
 %                                                                           %
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Peak alignment by dynamic programming}

PyMS provides functions to align GC-MS peaks by dynamic programming
\cite{Robinson07}.  The peak alignment by dynamic programming uses both peak
apex retention time and mass spectra.  This information is determined from the
raw GC-MS data by applying a series of processing steps to produce data that
can then be aligned and used for statistical analysis.  The details are
described in this chapter.

\section{Preparation of multiple experiments for peak alignment
by dynamic programming}

\subsection{Creating an Experiment}

\noindent
[ {\em This example is in pyms-test/60} ]

Before aligning peaks from multiple experiments, the peak objects need to be
created and encapsulated into PyMS experiment objects. During this process
it is often useful to pre-process the peaks in some way, for example to
null certain m/z channels and/or to select a certain retention time range.

To capture the data and related information prior to peak alignment, an
{\tt Experiment} object is used. The {\tt Experiment} object is defined in
{\tt pyms.Experiment.Class}.

The procedure is to proceed as described in the previous chapter. Namely: read
a file; bin the data into fixed mass values; smooth the data; remove the
baseline; deconvolute peaks; filter the peaks; set the mass range; remove
uninformative ions; and estimate peak areas.  The process is given in the
following program listing.

\begin{verbatim}
01  import sys, os
02  sys.path.append("/x/PyMS")
03
04  from pyms.GCMS.IO.ANDI.Function import ANDI_reader
05  from pyms.GCMS.Function import build_intensity_matrix_i
06  from pyms.Noise.SavitzkyGolay import savitzky_golay
07  from pyms.Baseline.TopHat import tophat
08  from pyms.Peak.Class import Peak
09  from pyms.Peak.Function import peak_sum_area
10
11  from pyms.Deconvolution.BillerBiemann.Function import BillerBiemann, \
12      rel_threshold, num_ions_threshold
13
14  # deconvolution and peak list filtering parameters
15  points = 9; scans = 2; n = 3; t = 3000; r = 2;
16
17  andi_file = "/x/PyMS/data/a0806_077.cdf"
18
19  data = ANDI_reader(andi_file)
20
21  # integer mass
22  im = build_intensity_matrix_i(data)
23
24  # get the size of the intensity matrix
25  n_scan, n_mz = im.get_size()
26
27  # smooth data
28  for ii in range(n_mz):
29      ic = im.get_ic_at_index(ii)
30      ic1 = savitzky_golay(ic)
31      ic_smooth = savitzky_golay(ic1)
32      ic_base = tophat(ic_smooth, struct="1.5m")
33      im.set_ic_at_index(ii, ic_base)
34
35  # do peak detection on pre-trimmed data
36
37  # get the list of Peak objects
38  pl = BillerBiemann(im, points, scans)
39
40  # trim by relative intensity
41  apl = rel_threshold(pl, r)
42
43  # trim by threshold
44  peak_list = num_ions_threshold(apl, n, t)
45
46  print "Number of Peaks found:", len(peak_list)
47
48  # ignore TMS ions and set mass range
49  for peak in peak_list:
50      peak.crop_mass(50,540)
51      peak.null_mass(73)
52      peak.null_mass(147)
53      # find area
54      area = peak_sum_area(im, peak)
55      peak.set_area(area)
56
\end{verbatim}

The resulting list of peaks can now be stored as an {\tt Experiment} object.

\begin{verbatim}
from pyms.Experiment.Class import Experiment
from pyms.Experiment.IO import store_expr

# create an experiment
expr = Experiment("a0806_077", peak_list)

# set time range for all experiments
expr.sele_rt_range(["6.5m", "21m"])

store_expr("output/a0806_077.expr", expr)
\end{verbatim}

Once an experiment has been defined, it is possible to limit the peak list to
a desired range using {\tt sele\_rt\_range()}.  The resulting experiment object
can then be stored for later alignment.

\subsection{Multiple Experiments}

\noindent
[ {\em This example is in pyms-test/61a} ]

This example considers the preparation of three GC-MS experiments for peak
alignment. The experiments are named `a0806\_077', `a0806\_078', `a0806\_079',
and represent separate GC-MS sample runs from the same biological sample.

The procedure is the same as above, and repeated for each experiment.  For
example:

\begin{verbatim}
...
# define path to data files
base_path = "/x/PyMS/data/"

# define experiments to process
expr_codes = [ "a0806_077", "a0806_078", "a0806_079" ]

# loop over all experiments
for expr_code in expr_codes:

    print "Processing", expr_code

    # define the names of the peak file and the corresponding ANDI-MS file
    andi_file = os.path.join(base_path, expr_code + ".cdf")
...

...
    # create an experiment
    expr = Experiment(expr_code, peak_list)

    # use same time range for all experiments
    expr.sele_rt_range(["6.5m", "21m"])

    store_expr("output/"+expr_code+".expr", expr)
\end{verbatim}

\noindent
[ {\em This example is in pyms-test/61b} ]

The previous set of data all belong to the same experimental condition.  That
is, they represent one group and any comparison between the data is a within
group comparison. For the original experiment, another set of GC-MS data was
collected for a different experimental condition.  This group must also be
stored as a set of experiments, and can be used for between group comparison.

The experiments are named `a0806\_140', `a0806\_141', `a0806\_142', and are
processed and stored as above (see pyms-test/61b).

\section{Dynamic programming alignment of peak lists from multiple experiments}

\noindent
\begin{itemize}
\item {\em This example is in pyms-test/62}
\item {\em This example uses the subpackage pyms.Peak.List.DPA, which in turn
uses the Python package 'Pycluster'.  For 'Pycluster' installation instructions
see the Section \ref{subsec:pycluster}.}
\end{itemize}

In this example the experiments 'a0806\_077', 'a0806\_078', and 'a0806\_079'
prepared in pyms-test/61a will be aligned, and therefore the script
pyms-test/61a/proc.py must be run first, to create the files
'a0806\_077.expr', 'a0806\_078.expr', 'a0806\_079.expr' in the directory
pyms-test/61a/output/. These files contain the post-processed peak lists
from the three experiments.

The input script required for running the dynamic programming alignment
is given below.

\begin{verbatim}
"""proc.py
"""

import sys, os
sys.path.append("/x/PyMS/")

from pyms.Experiment.IO import load_expr
from pyms.Peak.List.DPA.Class import PairwiseAlignment
from pyms.Peak.List.DPA.Function import align_with_tree, exprl2alignment

# define the input experiments list
exprA_codes = [ "a0806_077", "a0806_078", "a0806_079" ]

# within replicates alignment parameters
Dw = 2.5  # rt modulation [s]
Gw = 0.30 # gap penalty

# do the alignment
print 'Aligning expt A'
expr_list = []
expr_dir = "../61a/output/"
for expr_code in exprA_codes:
    file_name = os.path.join(expr_dir, expr_code + ".expr")
    expr = load_expr(file_name)
    expr_list.append(expr)
F1 = exprl2alignment(expr_list)
T1 = PairwiseAlignment(F1, Dw, Gw)
A1 = align_with_tree(T1, min_peaks=2)

A1.write_csv('output/rt.csv', 'output/area.csv')
\end{verbatim}

The explanation of the task performed by the input script is given below:

\begin{itemize}
\item Lines 16 and 17: input parameters for the alignment by dynamic
programming are defined. Dw is the retention time moduleation in seconds,
while Gw is the gap penalty.  These parameters are explained in detail
in \cite{Robinson07}
\item line 21: The list of experiments is loaded into the variable
named E1.  E1 is simply a Python list containing three expaeriment
objects as elements.
\item Line 22: The list of experiments is converted into the list of
alignments. Each experiment object is converted into the "alignment"
object. In this case the alignment object contains only a single
experiment, and is not really an alignment at all (this special case
is called 1-alignment). The variable F1 is simply a Python list
containing three alignment objects.
\item Line 23: all possible pairwise alignments (2-alignments) are
calculated from the list of 1-alignments. PairwiseAlignment() is
a class, and T1 is an object which contains the dendrogram tree that
maps the similarity relationship between the input 1-alignments,
and also 1-alignments themselves.
\item Line 24: The function align\_with\_tree() takes the object
T1 and aligns the individual alignment supplied with it according
the guide tree.  In this case, the individual alignment are
three 1-alignments, and the function align\_with\_tree() first
creates a 2-alignment from the two most similar 1-alignments
and then adds the third 1-alignment to this to create a
3-alignment. The parameter 'min\_peaks=2' specifies that any peak
column of the data matrix which has less than two peaks in the final
alignment will be dropped.  This is useful to clean up the data
matrix of accidental peaks that are not truly observed over the
set of replicates.
\item Line 27: the resulting 3-alignment is stored on disk, converted
into the alignment tables containing peak retention times ('rt1.csv')
and the corresponding peak areas ('area1.csv'). These two files are
plain ASCII files is CSV format, and are saved in the directory
05/output/.
\end{itemize}

\noindent
In general one is interested in the file 'area1.csv' which contains
the data matrix where the corresponding peaks are aligned in the
columns and each row corresponds to an experiment. The file 'rt1.csv'
is useful for manually inspecting the alignment in some GUI driven
program.

Running the above script with {\tt \$ python proc.py} produces the
following output:

\begin{verbatim}
01  Aligning input 1
02   -> Loading experiment from the binary file '../04/output/a0806_140.expr'
03   -> Loading experiment from the binary file '../04/output/a0806_141.expr'
04   -> Loading experiment from the binary file '../04/output/a0806_142.expr'
05   Calculating pairwise alignments for 3 alignments (D=2.50, gap=0.30)
06   -> 2 pairs remaining
07   -> 1 pairs remaining
08   -> 0 pairs remaining
09   -> Clustering 6 pairwise alignments. Done
10   Aligning 3 items with guide tree (D=2.50, gap=0.30)
11   -> 1 item(s) remaining
12   -> 0 item(s) remaining
\end{verbatim}

\section{Between-state alignment of peak lists from multiple experiments}

\noindent
[ {\em This example is in pyms-test/63 and pyms-test/61a} ]

The Example 5 demonstrates how the peaks lists are aligned within a single
experiment with multiple replicates (called "within-state alignment"). For
example, if there are 8 experimental replicates performed on wild-type
cells, Example 05 gives a recipe how to align such a set of experiments.
In practice one is often interested in comparing two experimental states,
ie. wild-type and mutant cells. In a typical experimental setup one would
collect multiple replicate experiments on each state (for example, 8
experimental replicates on wild-type cells and 8 on the mutant cells).
To analyze the results of such an experiment statistically one needs
to align the peak lists within each experimental state (wild-type and
mutant) and also between the two states. The result of such an alignment
would be the data matrix of integrated peak areas. In the example above
the data matrix would contain 16 rows (corresponding to 8 wild type and
8 mutant experiments), while the number of columns would be determined by
the number of unique peaks (metabolites) detected in the two experiments.

In principle, the method shown in the Example 5 could be used to align
experiments from the two or more experimental states each containing
multiple replicate experiments.  However, a more careful analysis of
the problem shows that the optimal approach to alignment is first
to align experiments within each set of replicates (within-state
alignment), and then to align the resulting alignments (between-state
alignment) \cite{Robinson07}. Within each state the experiments are
true replicates, and we expect, at least in theory, that all compounds
are observed in all experiments.  This is however not true between
the states,  for example in metabolites observed in wild-type versus
mutant cells, and this makes the alignment problem harder.

This example demonstrates how the peak lists from two cell states are
aligned, the cell state A consisting of three experiments aligned in
the Example 04 ('a0806\_140', 'a0806\_141', and 'a0806\_142'), and
the cell state B consisting of three experiments aligned in the
Example 04a ('a0806\_077', 'a0806\_078', 'a0806\_079'). The example
in pyms-text/04a/ is a simple repetition of the example in
pyms-text/04/ as explained in the Example 04 above only with
different experiments.

The alignment script used to align the two states A and B is given below:

\begin{verbatim}
01  """proc.py
02  """
03
04  import sys
05  sys.path.append("/home/current/proj/PyMS/")
06
07  from pyms.Experiment.IO import read_expr_list
08  from pyms.Peak.List.DPA.Function import exprl2alignment
09  from pyms.Peak.List.DPA.Class import PairwiseAlignment
10  from pyms.Peak.List.DPA.Function import align_with_tree
11
13  input1 = "input1"
14  input2 = "input2"
15
17  Dw = 2.5  # rt modulation [s]
18  Gw = 0.30 # gap penalty
19
21  print 'Aligning input 1'
22  E1 = read_expr_list(input1)
23  F1 = exprl2alignment(E1)
24  T1 = PairwiseAlignment(F1, Dw, Gw)
25  A1 = align_with_tree(T1, min_peaks=2)
26
27  print 'Aligning input 1'
28  E2 = read_expr_list(input2)
29  F2 = exprl2alignment(E2)
30  T2 = PairwiseAlignment(F2, Dw, Gw)
31  A2 = align_with_tree(T2, min_peaks=2)
32
34  Db = 10.0 # rt modulation
35  Gb = 0.30 # gap penalty
36
37  print 'Aligning input {1,2}'
38  T9 = PairwiseAlignment([A1,A2], Db, Gb)
39  A9 = align_with_tree(T9)
40
41  A9.write_csv('output/rt.csv', 'output/area.csv')
\end{verbatim}

\noindent
There are two external input files used in this script ('input1' and
'input2'), listing the experiments from the state A and state B. The
ifile 'input1' is identical as given in Example 5, while the listing
of input file 'input2' defines where are the experiment dumps for
the state B:

\begin{verbatim}
../04a/output/a0806_077.expr
../04a/output/a0806_078.expr
../04a/output/a0806_079.expr
\end{verbatim}

The explanations of the alignment script are given below:

\begin{itemize}
\item Lines 21-25 run the within-state experiment of the state A, and are
explained in the Example 5. Lines 27-31 are identical, and run the
within-state alignment of the state B. The within-state alignment of
experiments A is encapsulated in the variable A1, while the within-state
alignment of the experiments B is encapsulated in the variable A2.
\item Lines 34 and 34 specify the alignment parameters for between-state
alignment of A and B. In the example the retention time tolerance for
between-state alignment is greater compared to the retention time tolerance
for the within-state alignment as the two sets of replicates were
recorded on different days and we expect less fidelity in retention times
between them.
\item Lines 37-39 execute the alignment of two alignments. Exactly the
same functions are used as in the within-state alignment (at this point
the purpose of converting experiments to 1-alignments becomes apparent:
this allows a generalization of functions PairwiseAlignment() and
align\_with\_tree(), which always operate on the alignment objects.
\item Line 41: the resulting alignment is saved to a file.
\end{itemize}

Running the above script with the command {\tt \$ python proc.py} produces
the following output. Both pyms-text/04/proc.py and pyms-text/04a/proc.py
need to be run to create the experiment dumps that are input for the
alignment demonstrated here.

\begin{verbatim}
01  Aligning input 1
02   -> Loading experiment from the binary file '../04/output/a0806_140.expr'
03   -> Loading experiment from the binary file '../04/output/a0806_141.expr'
04   -> Loading experiment from the binary file '../04/output/a0806_142.expr'
05   Calculating pairwise alignments for 3 alignments (D=2.50, gap=0.30)
06   -> 2 pairs remaining
07   -> 1 pairs remaining
08   -> 0 pairs remaining
09   -> Clustering 6 pairwise alignments. Done
10   Aligning 3 items with guide tree (D=2.50, gap=0.30)
11   -> 1 item(s) remaining
12   -> 0 item(s) remaining
13  Aligning input 1
14   -> Loading experiment from the binary file '../04a/output/a0806_077.expr'
15   -> Loading experiment from the binary file '../04a/output/a0806_078.expr'
16   -> Loading experiment from the binary file '../04a/output/a0806_079.expr'
17   Calculating pairwise alignments for 3 alignments (D=2.50, gap=0.30)
18   -> 2 pairs remaining
19   -> 1 pairs remaining
20   -> 0 pairs remaining
21   -> Clustering 6 pairwise alignments. Done
22   Aligning 3 items with guide tree (D=2.50, gap=0.30)
23   -> 1 item(s) remaining
24   -> 0 item(s) remaining
25  Aligning input {1,2}
26   Calculating pairwise alignments for 2 alignments (D=10.00, gap=0.30)
27   -> 0 pairs remaining
28   -> Clustering 2 pairwise alignments. Done
29   Aligning 2 items with guide tree (D=10.00, gap=0.30)
30   -> 0 item(s) remaining
\end{verbatim}

\section{Comparing two peak lists by using dynamic programming alignment}

\noindent
[ {\em This example is in pyms-test/68} ]

The PyMS package pyms.Peak.List.Metric provides a function to compare two peak lists.
This allows peak detection methods from different programs to be evaulated or a peak
detection method to be compared to a 'known' or expert evaluated result. The following
example compares Xcalibur peak detection and AMDIS peak detection.

\begin{verbatim}
>>> from from pyms.Experiment.IO import load_amdis_expr,load_xcalibur_expr
>>> from pyms.Peak.List.Metric import metric
>>> andi_file = "pyms-data/121107B_10.CDF"
>>> xcalibur_peaks_file = "pyms-data/121107B_10_xcalibur_peaks.txt"
>>> amdis_peaks_file = "pyms-data/121107B_10.ELU"
>>> amdis_expr = load_amdis_expr(amdis_peaks_file)
 -> Processing AMDIS experiment
 -> Reading AMDIS ELU file 'pyms-data/121107B_10.ELU'
>>> xcalibur_expr = load_xcalibur_expr(xcalibur_peaks_file,andi_file)
 -> Processing Xcalibur experiment
 -> Reading Xcalibur peak file 'pyms-data/121107B_10_xcalibur_peaks.txt'
 -> Processing netCDF file 'pyms-data/121107B_10.CDF'
    [ 7038 scans, masses from 70 to 600 ]
>>> metric_result = metric(amdis_expr.peaks, xcalibur_expr.peaks)
>>> print "Metric distance is ",metric_result
Metric distance is  0.89724073048
\end{verbatim}

The full list of matching peaks and distances between individual peaks can be displayed
by setting the verbose flag:

\begin{verbatim}
>>> metric_result = metric(amdis_expr.peaks, xcalibur_expr.peaks, verbose=True)
[-- output deleted --]
33.71	-
33.71	-
33.98	33.98	0.43
34.50	34.50	0.03
-	35.01
35.08	-
-	35.77
35.92	-
36.32	-
36.60	-
36.65	-
37.14	-
37.44	37.44	0.31
-	39.60
40.99	40.99	0.43
41.59	-
-	42.93
Metric distance is  0.89724073048
\end{verbatim}
