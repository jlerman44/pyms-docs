% chapter02.tex

 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %                                                                           %
 %    PyMS documentation                                                     %
 %    Copyright (C) 2005-8 Vladimir Likic                                    %
 %                                                                           %
 %    The files in this directory provided under the Creative Commons        %
 %    Attribution-NonCommercial-NoDerivs 2.1 Australia license               %
 %    http://creativecommons.org/licenses/by-nc-nd/2.1/au/                   %
 %    See the file license.txt                                               %
 %                                                                           %
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Using PyMS}

\section{Running PyMS}

PyMS can be run either interactively or from the script. When run
in an interactive session commands are issued interactively through
a Python shell. When run in the script mode the commands are collected
into a file which is then passed to python for processing.

It is possible to run PyMS under the default Python shell. However
we recommend using IPython, enhanced python shell \cite{ipython},
for interactive work with PyMS. IPython has a number of features
that make interactive work easier.

\section{PyMS components}

PyMS is a Python package which contains a number of sub-packages,
each of which provides certain functionality. This includes for
example, 

\begin{itemize}
\item Baseline/ -- Baseline correction module.
\item Display/ -- Visualisation module.
\item IO/ -- Contains functions for reading of ANDI/MS data.
\item Noise/ -- Noise smoothing and analysis.
\item Peak/ -- Peak-related modules (including manipulation of peak
lists).
\end{itemize}

PyMS is a collection of loosely coupled sub-packages. It is possible
to load only one or a few sub-packages in Python (i.e. a part of PyMS),
if a limited functionality is required. For example, it is possible
to read experimental data without having other parts of PyMS
available. Reading experimental data in the ANDI/MS format requires
that the sub-package pyms.IO is loaded in the Python environment,
and this can be done independently from loading other sub-packages,
such as pyms.Baseline (provide baseline correction) or pyms.Display
(provides visualisation).

\section{Reading ANDI/MS data}

ANDI/MS data format stands for Analytical Data Interchange for Mass
Spectrometry, and is model for the description of mass spectrometric
data developed in 1994 by Analytical Instrument Association. ANDI/MS 
is essentially a recommendation. It is up to individual vendors of
mass spectrometry processing software to implement "export to ANDI/MS"
feature in their software. Furthermore, it is vendor's good will to
implement ANDI/MS specification properly. Because of these limitations
it is difficult to be certain that one can properly read ANDI/MS
files from a particular vendor without testing this.

The sub-package pyms.IO provides capabilities to read the raw GC-MS
data in the ANDI/MS format. The basic function to read ANDI/MS data
provided by the pyms.IO subpackage is IO.ANDI.ChemStation(). The
name is a reminder that this function has been reasonably tested
only on the data exported from Agilent ChemStation software.
In fact, IO.ANDI.ChemStation() was implemented based on comparisons
with ChemStation, i.e. data read by PyMS was compared to the
the original data in ChemStation to confirm that IO.ANDI.ChemStation()
reads the data properly.

In theory the same function should be able to read files created by
other software packages that supports export to ANDI/MS. Quick tests
suggests that IO.ANDI.ChemStation() can read properly ANDI/MS exported
from at least few other vendors, including Leco (ChromaTOF software).
This however requires a proper testing and verification, because of
the reasons mentioned before.
 
In an interactive session from IPython, the ANDI/MS file can be loaded
in the memory as follows:

\begin{verbatim}
In [1]: from pyms import IO

In [2]: data = IO.ANDI.ChemStation("CHEMSTATION.CDF")
 -> Processing netCDF file 'CHEMSTATION.CDF'
    [ 2784 scans, masses from 50 to 550 ]
\end{verbatim}

Where 'CHEMSTATION.CDF' is the GC-MS data in ANDI/MS format.

At this point it would be helpful to introduce a few terms.
IO.ANDI.ChemStation() is actually a {\em class}, and the above command
creates the object 'data' which is an {\em instance} of the class
IO.ANDI.ChemStation. A class is a template for making instances.
A class may have one or more {\em attributes} which are inherited
by every instance made out of the class, and initialized when the
instance is created.

The above command creates the object {\tt data}, which has the
following methods associated with is:

\begin{itemize}

\item {\tt get\_filename()} -- Returns the name of the file from which
the data was loaded. Usage example:

\begin{verbatim}
In [3]: data.get_filename()
Out[3]: 'CHEMSTATION.CDF'
\end{verbatim}

\item {\tt get\_ic\_at\_index(i)} -- Returns an IonChromatogram
object at index i. For example, to get the first ion chromatogram
from the data matrix:

\begin{verbatim}
In [3]: ic = data.get_ic_at_index(1)
\end{verbatim}

\item {\tt get\_ic\_at\_mass(mz)} -- Returns an IonChromatogram
object corresponding to given m/z. For example, to get the ion
chromatogram that corresponds to m/z = 73:

\begin{verbatim}
In [3]: ic = data.get_ic_at_mass(73)
\end{verbatim}

\item {\tt get\_intensity\_matrix()} -- Returns the entire data
matrix, i.e. time vs m/z as numarray object. Usage example:

\begin{verbatim}
In [3]: im = data.get_intensity_matrix()
In [4]: len(im)
Out[4]: 2784
In [5]: len(im[0])
Out[5]: 501
\end{verbatim}

This data matrix contains 2784 time points (MS scans) and each time
point corresponds to a mass spectrum of 501 m/z points.

\end{itemize}

