% chapter02.tex

 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %                                                                           %
 %    PyMS documentation                                                     %
 %    Copyright (C) 2005-8 Vladimir Likic                                    %
 %                                                                           %
 %    The files in this directory provided under the Creative Commons        %
 %    Attribution-NonCommercial-NoDerivs 2.1 Australia license               %
 %    http://creativecommons.org/licenses/by-nc-nd/2.1/au/                   %
 %    See the file license.txt                                               %
 %                                                                           %
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Using PyMS}

\section{Introduction}

PyMS can be run either interactively or from the script in "batch" mode.
When run in an interactive session commands are issued interactively through
a Python shell. When run in the script mode the commands are collected
into a file ('python script') which is then passed to python interpreter
or processing.

PyMS is a Python package which consists of several loosely coupled
sub-packages. It is possible to load only one or a few sub-packages
in Python (i.e. a part of PyMS), if a limited functionality is required.
For example, one may want to use PyMS to read experimental data without
having other parts of PyMS available.

\section{Reading ANDI-MS data}

\subsection{About ANDI-MS data format}

ANDI-MS data format stands for Analytical Data Interchange for Mass
Spectrometry, and is model for the description of mass spectrometric
data developed in 1994 by Analytical Instrument Association. ANDI-MS 
is essentially a recommendation. It is up to individual vendors of
mass spectrometry processing software to implement "export to ANDI-MS"
feature in their software. Furthermore, it is vendor's good will to
implement ANDI-MS specifications properly. Because of these limitations
it is difficult to be certain that one can properly read ANDI-MS
files from a particular vendor without testing this.

\subsection{Reading the ANDI-MS data with PyMS}

The PyMS sub-package pyms.IO provides capabilities to read the raw GC-MS
data stored in the ANDI-MS format. More specifically, the function
IO.ANDI.ChemStation() provides interface to ANDI-MS data files saved
from Agilent ChemStation software. The name is a reminder that this
function has been reasonably tested only on the data exported from
Agilent ChemStation.

In an interactive session from Python, the ANDI-MS file can be loaded
in the memory as follows:

\begin{verbatim}
>>> from pyms import IO
>>> data = IO.ANDI.Class.ChemStation('0510_217.CDF')
 -> Processing netCDF file '0510_217.CDF'
    [ 2784 scans, masses from 50 to 550 ]
>>>
\end{verbatim}

Where '0510\_217.CDF' is the name of the GC-MS data saved in the ANDI-MS
format from the Agilent ChemStation software.  The above command creates
the object 'data' which is an {\em instance} of the class IO.ANDI.ChemStation.
The instance 'data' has several attributes and methods associated with it:

\begin{itemize}

\item {\tt get\_filename()} -- Returns the name of the file from which
the data was loaded. Usage example:

\begin{verbatim}
>>> data.get_filename()
'0510_217.CDF'
\end{verbatim}

\item {\tt get\_ic\_at\_index(i)} -- Returns an IonChromatogram object
at index i.  For example, to get the first ion chromatogram from the data
matrix:

\begin{verbatim}
>>> ic = data.get_ic_at_index(1)
\end{verbatim}

\noindent
An IonChromatogram object is the one dimensional time vector containing
mass intensities.  One often deals with two types of IonChromatogram
objects: ion chromatograms at particular m/z value (for example, ion
chromatograms at m/z = 65), or total ion chromatograms (TICs), which
contain the sum of intensities for all masses at any given time point. 
The nature of an IonChromatogram object can be revealed by the content
of the attribute '\_mass', which is set to None if the ion chromatogram
is TIC; otherwise it contains the m/z value of the ion chromatogram.
Continuing the previous example:

\begin{verbatim}
>>> ic._mass
51
\end{verbatim}

\noindent
This shows that the first ion chromatogram in the data file is for
m/z = 51.

\item {\tt get\_ic\_at\_mass(mz)} -- Returns an IonChromatogram
object corresponding to given m/z. For example, to get the ion
chromatogram that corresponds to m/z = 73:

\begin{verbatim}
>>> ic = data.get_ic_at_mass(73)
>>> ic._mass
73
\end{verbatim}

\item {\tt get\_intensity\_matrix()} -- Returns the entire data
matrix, i.e. time vs m/z as numarray object. Usage example:

\begin{verbatim}
>>> im = data.get_intensity_matrix()
>>> len(im)
2784
>>> len(im[0])
501
\end{verbatim}

This data matrix contains 2784 time points (MS scans) and each time
point corresponds to a mass spectrum of 501 m/z points.

\end{itemize}

